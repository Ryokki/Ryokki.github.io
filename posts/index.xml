<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog</title>
    <link>https://ryokki.github.io/posts/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 22 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://ryokki.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【读书笔记】A Philosophy of Software Design</title>
      <link>https://ryokki.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0a-philosophy-of-software-design/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0a-philosophy-of-software-design/</guid>
      <description>为什么读这本书？这本书主要关于设计软件系统以最小化其复杂性，而控制复杂度是程序员的关键能力之一。
Reference 资料：
 软件设计的哲学第二版中文翻译 By Yingang A Philosophy of Software Design | John Ousterhout | Talks at Google - YouTube A Philosophy of Software Design  读书笔记(great)：
 https://blog.pragmaticengineer.com/a-philosophy-of-software-design-review/ Philosophy of Software Design 第九章 - 合并还是拆分 《A Philosophy of Software Design》心得 2 — 透过模组设计降低软件复杂度，从介面开始｜ExplainThis  读书笔记(normal)
 Massive Technical Interviews Tips: A Philosophy of Software Design A Philosophy of SoftwareDesign - 知乎 [[02. naughty 读书笔记：A Philosophy of Software Design]] 降低软件复杂性一般原则和方法 - 美团技术团队  1-3 复杂度 模块的复杂度 = 模块内部复杂度 + 模块外部复杂度</description>
    </item>
    
    <item>
      <title>如何阅读源代码——以一个tiny git实现为例</title>
      <link>https://ryokki.github.io/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 19 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E4%BB%A3%E7%A0%81/</guid>
      <description>References  如何阅读一份代码？ 我是怎么读代码的 如何阅读一份源代码？（2020年版）  先通过文档了解全景，再逐步深入代码 多问自己几个问题。为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？ 一边读一边记录，还要复盘 最后要总结输出
记一个读tiny git实现的例子 流程
 git init git status echo hello &amp;gt; hello; git add . git commit -m &amp;ldquo;create hello file&amp;rdquo;  init后文件如下
kkbabe in ~/myproject/rezero_git/.zit on main ● λ cat HEAD ref: refs/heads/main% kkbabe in ~/myproject/rezero_git/.zit on main ● λ ls HEAD index objects status测试
 添加hello 更新hello 删掉hello 添加world  </description>
    </item>
    
    <item>
      <title>设计优惠券系统</title>
      <link>https://ryokki.github.io/posts/%E8%AE%BE%E8%AE%A1%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/%E8%AE%BE%E8%AE%A1%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F/</guid>
      <description>目标 设计一个通用的优惠券系统，供以后使用。目前想到的场景如下
 绑定邀请码后自动给用户发放一些优惠券（项目版本、算力包、加油包 各一张，折扣10%，有效期一个月 ） 后续会把pro版买算力包9折、服务商版算力包7折变成优惠券（这个不搞成优惠券，这个算另一种折扣？） 后续可能有一些发优惠券的活动  系统设计 优惠券
 优惠券名称 覆盖范围：商品/组合/行业/全平台 优惠形式：折扣/固定金额 使用限制：订单（满足金额）/用户（版本、注册时间超过X）/项目（版本） 使用次数：1次/多次 使用时间：固定有效期/推移量  优惠券逻辑主要是两阶段
 发放券阶段：什么时候，发给谁，什么券 领券后：什么用户，什么时间，什么订单可用优惠券。能优惠多少。  数据模型 Coupon  id 优惠规则  discount_type (enum: PERCENTAGE_DISCOUNT 折扣券, FIXED_AMOUNT_DISCOUNT立减券) discount_amount 优惠券价值（百分比或减免金额）   订单门槛金额：minimum_order_amount 用户限制：List&amp;lt;PlanType&amp;gt; applicable_plans 项目限制：List&amp;lt;ProjectPlanType&amp;gt; applicable_project_plans 商品限制: List&amp;lt;ProductTypeDetail&amp;gt; applicable_project_type_details 可用时间  expired_at validity_period    这里比较麻烦的是商品范围限制字段如何设计
 最简单的是productIds，但是这个有个问题，后面加产品类型的时候，得去改以前的一堆优惠券 为了解决1的问题，可以再搞个product_group表，coupon里存List&amp;lt;product_group_id&amp;gt;。这样后续加产品类型的时候，就不需要改优惠券，只需要改product_group。这还是很麻烦 🌟 其实不需要product_group表，就可以做到给一批商品分类：通过productType + productDetail来确定一批商品，定义为ProductTypeDetail  项目版本  projectPlanType paymentCycle Long templateId   多客户端  paymentCycle   算力包  computingPowerKitType period   加油包  computingPowerAddonType period      例如：</description>
    </item>
    
    <item>
      <title>design pattern(todo)</title>
      <link>https://ryokki.github.io/posts/design-pattern/</link>
      <pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/design-pattern/</guid>
      <description>References:
 GitHub - Jueee/design-patterns: 《设计模式:可复用面向对象软件的基础》学习笔记 GitHub - ukihsoroy/design-pattern: 🐱‍🏍你不能不学的设计模式合集。 GitHub - fuzhengwei/itstack-demo-design: :art: 《重学Java设计模式》是一本互联网真实案例实践书籍。以落地解决方案为核心，从实际业务中抽离出，交易、营销、秒杀、中间件、源码等22个真实场景，来学习设计模式的运用。欢迎关注小傅哥，微信(fustack)，公众号：bugstack虫洞栈，博客：https://bugstack.cn design-pattern 装饰设计（装饰者模式 / 装饰器模式） Design Pattern Catalog | Java Design Patterns GitHub - iluwatar/java-design-patterns: Design patterns implemented in Java GitHub - kshitijmishra23/low-level-design-concepts: Code Samples to understand SOLID design principles and Design Patterns in JAVA. 设计模式之美不错 因为王争的那个回答不错 图解设计模式 短评  </description>
    </item>
    
    <item>
      <title>jimmer</title>
      <link>https://ryokki.github.io/posts/jimmer/</link>
      <pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/jimmer/</guid>
      <description>References  官方文档  初识 。。。 好多没看懂 先跳过
快速预览 这里，列举三个实体类型，BookStore、Book、Author和TreeNode，作为当前章节所有讨论的前提假设。 @Entity public interface BookStore { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) Long id(); String name(); @Nullable String website(); @OneToMany(mappedBy = &amp;#34;store&amp;#34;) List&amp;lt;Book&amp;gt; books(); } @Entity public interface Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) Long id(); @Key String name(); @Key int edition(); BigDecimal price(); @Nullable @ManyToOne BookStore store(); @ManyToMany List&amp;lt;Author&amp;gt; authors(); } @Entity public interface Author { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) UUID id(); @Key String firstName(); @Key String lastName(); Gender gender(); @ManyToMany(mappedBy = &amp;#34;authors&amp;#34;) List&amp;lt;Book&amp;gt; books(); } 任意动态查询 BookTable table = Tables.</description>
    </item>
    
    <item>
      <title>jpa entity lifecycle</title>
      <link>https://ryokki.github.io/posts/jpa-entity-lifecycle/</link>
      <pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/jpa-entity-lifecycle/</guid>
      <description>Entity Lifecycle Model in JPA &amp;amp; Hibernate Spring Data JPA: Entity Lifecycle Model | by Suraj Mishra | Javarevisited | Medium、 Hibernate Persistence Context and Object’s LifeCycle | MyArchiBook language agnostic - Using an ORM or plain SQL? - Stack Overflow Hibernate Proxies - Why they&amp;rsquo;re used and how to unproxy them What is Object/Relational Mapping? - Hibernate ORM  关键词：jpa persistence context &amp;quot;dirty check&amp;quot; JPA: Persistence Context And Dirty Check Mechanism | Thameena | Developer Journal 目标：理解entity如何状态变化，以及为什么这么设计，解决了什么问题。【看起来就是ORM的普遍问题？】</description>
    </item>
    
    <item>
      <title>改善拖延和习惯</title>
      <link>https://ryokki.github.io/posts/%E6%8B%96%E5%BB%B6-%E4%B9%A0%E6%83%AF/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/%E6%8B%96%E5%BB%B6-%E4%B9%A0%E6%83%AF/</guid>
      <description> 每個人都是拖延症患者,怎麼克服拖延症？ - 全职妈妈爱生活 早睡 我是如何改掉熬夜這個習慣的？睡的好才能學的好。 - 全职妈妈爱生活（后面看）  什么是拖延 - learn from Inside the mind of a master procrastinator。 脑子里： 即时满足的猴子 + 理性决策的思考者。这个猴子眼中没有任何未来的规划，only for easy and fun. 这种即时满足在原始时代没有问题。
拖延症就是即时满足的猴子占据了大部分时间。在不该即时满足的即时满足的时候得到的快乐不是快乐，因为会带来内疚和自我憎恨。
只有恐慌panic monster会驱逐这个猴子（DDL..),
而且DDL快来的时候，这个猴子还会开始做无意义的事情，明明没有乐趣的事情，也不愿意开始做那个重要的事情
(太真实)
因为拖延严重影响了生活，带来了强烈的挫败感
 with deadline: 拖延是有限的 no deadline: 往往是没有下文了，因为panic monster不会出现。这些往往不被发现，但是大量长期不快乐、内疚的来源。活的像一个旁观者（真实  改善拖延的做法  番茄钟 為什麼番茄鐘工作法這麼強大？Coursera Learning How To Learn《學習如何學習》心得1 - 全职妈妈爱生活 先做最困难最重要的事。 避免掉入僵尸模式（例如起床后刷b站，一下就是一个小时），要意识到这些trigger、形成新习惯（例如规定一起床要做什么事）、改变地点（比如去图书馆） 不要使用意志力。意志力是一项宝贵的资源，也是需要耗费大脑非常多的能量。应该把意志力用在更有价值的地方，比如专注于对我们重要但是很有难度的任务上面。【所以我应该尽可能远离诱惑】 让自己有好的状态-运动/睡眠的重要性，状态好更容易正向思考以及主动 保有信念，I can do it.我们拖延主要是我们大脑会觉得很难，所以我们会主动逃避，避免痛苦。如果我们改变信念，觉得自己可以做到，就可以欺骗大脑，避免大脑主动逃避拖延。【或者降低目标，不要求做的多好，目标是做个破烂出来就行】 设定截止时间。设定每天工作或任务的截止时间一方面是奖励一些时间给自己，这个时间就是可以随意享受的时间，另一方面是让自己大脑充电，让第二天更有效率。现在我每天都会设定9:30后就关掉电脑关掉手机，敷面膜、泡澡或者看电影，然后睡前在看一会书。 奖励自己。当我们真的改掉一个坏习惯，养成一个好习惯的时候，要好好奖励自己。比如我现在每天都会写作2个番茄钟，如果我这一个月都可以做到，我就排除万难去看一部电影。  </description>
    </item>
    
    <item>
      <title>Git Internal（施工中）</title>
      <link>https://ryokki.github.io/posts/git-internal/</link>
      <pubDate>Wed, 01 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/git-internal/</guid>
      <description>Reference
 Git Doc: All commands Git Pro2 Understanding Git — Data Model. GIt is a great and powerful VCS but can… | by Zvonimir Spajic | Medium Deep Dive Into Git • Edward Thomson • GOTO 2015 - YouTube You searched for database internal - The GitHub Blog 这里有五篇git internal，看起来更deep，可以做完gitlet后看 从 Commit 到 Branch，一文明白 git 到底怎么回事 - 掘金 （写的巨好） 从 Commit 到 Branch，一文明白 git 到底怎么回事 - Chenyu&amp;rsquo;s Blog （原理 OR 实现 OR 提交 &amp;ldquo;commits-are-snapshots-not-diffs&amp;rdquo;） Commits are snapshots, not diffs - The GitHub Blog : r/programming git 工作原理与撤销操作图解 | Shall We Code?</description>
    </item>
    
    <item>
      <title>git学习</title>
      <link>https://ryokki.github.io/posts/git%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ryokki.github.io/posts/git%E5%AD%A6%E4%B9%A0/</guid>
      <description>All entity
 working area/ staging area: 工作区和暂存区，这里是所有这次改动的信息（基于branch latest commit {snapshot}） commit: commit 是 tree + parents + log  root tree id: snapshot of file system commit info: commit message，author, time parent commit id: commit list   tree: snapshot of file system under the dir, blob: snapshot of file branch:a pointer to latest commit, it&amp;rsquo;s the base of working area  Point
 all object(commit, tree, blob) 都是不可变的，因为只要内容变了，id sha就会变。  New learning from blog</description>
    </item>
    
  </channel>
</rss>
