<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>事务详解1——隔离级别</title>
    <link href="/2022/09/03/database/%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A31%E2%80%94%E2%80%94%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/09/03/database/%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A31%E2%80%94%E2%80%94%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要讨论的是事务隔离级别，从事务隔离级别的起源，标准和本质来深入分析事务并发控制下的隔离级别的原理和实现。阅读文本前，你需要具备事务的一些基本知识，本文的第一章节会回顾我们所熟知的有关隔离级别和事务的基础知识。如果你了解事务的一般基础知识，你可以跳过第一章节，直接阅读第二章节。</p><h2 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h2><h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p><h1 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h1><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）:"></a><strong>原子性（Atomicity）</strong>:</h2><p>事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</p><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency） :"></a><strong>一致性（Consistency）</strong> :</h2><p>一致性是指事务必须使数据库从一个一致性状态变成另一个一致性状态，也就是事务执行前后必须处于一致性状态。</p><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）:"></a><strong>隔离性（Isolation）</strong>:</h2><p>一个事务所做的修改在最终提交以前，对其他事务是不可见，当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其它的事务操作所干扰，多个并发事务之间要相互隔离。</p><h2 id="持久性（Durability）："><a href="#持久性（Durability）：" class="headerlink" title="持久性（Durability）："></a><strong>持久性（Durability）</strong>：</h2><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="事务并发的问题"><a href="#事务并发的问题" class="headerlink" title="事务并发的问题"></a>事务并发的问题</h2><h3 id="【1】脏读（读取未提交数据）"><a href="#【1】脏读（读取未提交数据）" class="headerlink" title="【1】脏读（读取未提交数据）"></a>【1】脏读（读取未提交数据）</h3><p>当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。</p><table><thead><tr><th align="left">时间顺序</th><th align="left">转账事务A</th><th align="left">取款事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"></td><td align="left">开始事务</td></tr><tr><td align="left">2</td><td align="left">开始事务</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">查询余额1000</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">取出 500 余额为 500</td></tr><tr><td align="left">5</td><td align="left">查询账户余额 500</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">出错，撤销事务 余额为1000</td></tr><tr><td align="left">7</td><td align="left">汇入100 余额 600</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">提交事务</td><td align="left"></td></tr><tr><td align="left">备注</td><td align="left">按照逻辑，转账事务读取了B 撤销后的事务出现脏读</td><td align="left"></td></tr></tbody></table><h3 id="【2】不可重复读（前后多次读取，数据内容不一致）"><a href="#【2】不可重复读（前后多次读取，数据内容不一致）" class="headerlink" title="【2】不可重复读（前后多次读取，数据内容不一致）"></a>【2】不可重复读（前后多次读取，数据内容不一致）</h3><p>在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据</p><table><thead><tr><th align="left">时间顺序</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">第一次查询余额 100</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">开始事务</td></tr><tr><td align="left">4</td><td align="left">其他操作</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left"></td><td align="left">消费30 余额 变为 70</td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">提交事务</td></tr><tr><td align="left">7</td><td align="left">第二次查询 余额为70</td><td align="left"></td></tr><tr><td align="left">备注</td><td align="left">按照正确的逻辑，事务A前后两次读取的数据应该一致</td><td align="left"></td></tr></tbody></table><h3 id="【3】幻读（前后多次读取，数据总量不一致）"><a href="#【3】幻读（前后多次读取，数据总量不一致）" class="headerlink" title="【3】幻读（前后多次读取，数据总量不一致）"></a>【3】幻读（前后多次读取，数据总量不一致）</h3><p>在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p><table><thead><tr><th align="left">时间顺序</th><th align="left">统计金额事务</th><th align="left">转账事务 B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"></td><td align="left">开始事务</td></tr><tr><td align="left">2</td><td align="left">开始事务</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">统计金额为（100个账户）10000</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">5</td><td align="left"></td><td align="left">新增一个存款账户，余额为100</td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">提交事务</td></tr><tr><td align="left">7</td><td align="left">再次统计存款 为 10100 元</td><td align="left"></td></tr><tr><td align="left">备注</td><td align="left">按照正确的逻辑，统计事务后出现了幻读（数据行发生了变化）</td><td align="left"></td></tr></tbody></table><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>为了解决多个事务并发会引发的问题，进行并发控制。数据库系统提供了四种事务隔离级别供用户选择。</p><h3 id="Read-Uncommitted-读未提交："><a href="#Read-Uncommitted-读未提交：" class="headerlink" title="Read Uncommitted 读未提交："></a><strong>Read Uncommitted 读未提交</strong>：</h3><p>即允许当前会话事务读取到其他会话中未提交事务修改的数据，可能导致脏读。</p><h3 id="Read-Committed-读已提交："><a href="#Read-Committed-读已提交：" class="headerlink" title="Read Committed 读已提交："></a><strong>Read Committed 读已提交</strong>：</h3><p>只能读取到已成功提交事务的数据，因此可以避免发生脏读，但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。即事务前后两次读取的数据不一致。</p><h3 id="Repeatable-Read-重复读"><a href="#Repeatable-Read-重复读" class="headerlink" title="Repeatable Read 重复读"></a><strong>Repeatable Read 重复读</strong></h3><p>重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。但可能出现幻读。（这里为什么会出现幻读，参见后面的文章）</p><h3 id="Serializable-可串行化："><a href="#Serializable-可串行化：" class="headerlink" title="Serializable 可串行化："></a><strong>Serializable 可串行化</strong>：</h3><p>所有的增删改查串行执行。(这里强调可串行化，而非真生意义上的串行化。读写操作是并发的，但是其效果等价于串行化执行，因此这里用可串行化来表述)</p><h2 id="隔离级别的本质"><a href="#隔离级别的本质" class="headerlink" title="隔离级别的本质"></a>隔离级别的本质</h2><p>上一个章节，对事务公共认知做了一个简单的介绍，这些认知是基于大众的普遍知识。你可能意识到，上一节的只是事实上来说并不完全，因为似乎少了某些异常情况。例如说，丢失更新等。<br>事实上，你的感觉并没有错，因为确实在异常中有很多不尽如人意的地方，这都取决于这套标准的制定。接下来，我将展开一些对着写公共认知更为细节的问题来讨论。</p><h2 id="标准的提出"><a href="#标准的提出" class="headerlink" title="标准的提出"></a>标准的提出</h2><p>我们知道，这些知识在任何一部MySql教程中都有不少的介绍。即便如此，这些隔离级别其实并不是由MySql定制的，而是由一个组织名叫ANSI的组织制定的。</p><blockquote><p>ANSI：美国国家标准学会（AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）成立于1918年。当时，美国的许多企业和专业技术团体，已开始了标准化工作，但因彼此间没有协调，存在不少矛盾和问题。为了进一步提高效率，数百个科技学会、协会组织和团体，均认为有必要成立一个专门的标准化机构，并制订统一的通用标准。</p></blockquote><p>要了解隔离级别的标准，我们必须要知道隔离级别的本质，也即是说我们为什么要设定隔离级别。</p><h2 id="隔离级别的本质-1"><a href="#隔离级别的本质-1" class="headerlink" title="隔离级别的本质"></a>隔离级别的本质</h2><p>在第一章节中，我们给出的事务四个特性ACID并不严谨，本文我们引用了数据库领域的大神Jim Gray对其的定义,Jim Gray是事务处理方面的大师，本文中很多内容都来自他的专著和论文。为避免翻译引入的歧义，这里我们直接引用原文。</p><ul><li>Atomicity: Either all the changes from the transaction occur (writes, and messages sent), or none occur.</li><li>Consistency: The transaction preserves the integrity of stored information.</li><li>Isolation: Concurrently executing transactions see the stored information as if they were running<br>erially (one after another).</li><li>Durability: Once a transaction commits, the changes it made (writes and messages sent) survive any system failures.</li></ul><p>在上述隔离性（Isolation）的定义中，我们可以发现其目标是使并发事务的执行效果与串行一致。并从一致性（Consistency）定义中知道，事务是需要将数据状态从一个变成另一个状态。假设我们有数据x &#x3D; 1，经过若干事务之后，我们需要让x &#x3D; x’。</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645758703747-20221130195200370.png" alt="img"></p><p>注意事务的顺序，当顺序确定之后，对于事务对数据的改变就是原子性的。也就是说事务2不可以在事务1前面更改数据状态，必须从事务A1结束后的状态开始执行。<br>但我们知道，事务中会包含对数据的Read操作和Wirte操作。Read操作不会影响数据的状态，但是Wirte则会影响数据的状态。<br>我们假设x的初始值是x &#x3D; 1,事务A由（Read(x), Wirte(x, x &#x3D;2), Read(x), Wirte(x, x &#x3D;1) 的操作序列组成。那么对x的状态变化如下图：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645758868868-20221130195200538.png" alt="img"></p><p>假如，此时有个事务2，序列为(Read(x), Wirte(x,x + 1)),状态为下图：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645758966889-20221130195200625.png" alt="img"></p><p>假设我们事务执行的顺序为[事务A, 事务B],则会出现这样一个串行化的序列：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645759042722-20221130195200717.png" alt="img"></p><p>这里的某种调度就是 Read 和Wirte 的排序方式。<br>​但是事实是，现代操作系统中，多核cpu已经普及，为了提高事务执行的效率，不同的事务操作可能会分配到不同的核心。但是这样做，就有可能破坏事务的一致性。因为事务的执行顺序不能随心所欲，必须要串行化执行，那怎么样才能利用多核cpu让事务并发执行且满足事务的串行化效果呢？答案就是串行化理论。</p><p>串行化调度和可串行化理论：</p><blockquote><p>为了提高数据库的执行效率，显然我们需要并发的执行各个事务，如果存在调度S，对于数据库的任何状态，其执行结果完全等价于另一个串行调度S’，称这样的调度S为可串行化调度（serializable schedule）。</p></blockquote><blockquote><p>对比串行调度，等价的可串行化调度可就多了（比如：最终等价，视图等价冲突等价），并发度大幅提升，但我们又该如何实现并发控制才能校验出一个调度是可串行化的？总不能先按串行调度执行，再对比结果吧？我们需要一个更加易于验证的条件，并且保证满足这个条件的调度是一定是可串行化的，这就是可串行化理论。</p></blockquote><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645759263475-20221130195200848.png" alt="img"></p><p>根据观察，我们只要让事务B的每个操作起始状态和串行化的起始状态保持一致，其他的时间阻塞等待就可以实现串行化的效果。例如：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645759339734-20221130195200947.png" alt="img"></p><p>因为事务B在串行执行的时候，第一个Read操作的起始状态为Ax&#x3D;1，那么，我将这个操作提前到事务A相同的区间开始，事务B Wirte操作起始状态不满足的情况下阻塞等待。这样一来，我们就可以通过一个并行调度来降低事务A + 事务B的总执行时间。因此，我们称这个调度是可串行化调度。</p><p>串行化的理论很复杂，包括：两阶段锁协议（2PL）, 独占&#x2F;共享锁（Lock）, 视图等价（view equivalence），冲突等价（conflict equivalence）,History 等等概念和复杂的数学公式，以及可串行化的条件和证明。很多数据库中的实现都会有这个理论的影子，由于太过复杂，这里我们不在展开。这里提出这个概念，是想告诉读者，事务的并发控制的解决方案，是经过一系列的科学的理论证明的，不是一拍脑门就决定的。本文系列文章尽量用可以理解的方式告诉读者这个理论的原理。</p><p>回到主题，事实上，大多时候我们无法控制事务B的开始时间（随机出现的）。但是我们可以通过阻塞或者其他合理调度来提高效率。有时候，提高了效率却又会出现错误状态。</p><p>事务B的起始时间可能在事务A区间的任何时候，如果不进行阻塞那么就会破坏事务的一致性要求。例如下图，x最后等于3：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645760135914-20221130195201294.png" alt="img"></p><p>我们称这种破坏一致性的现象成为异常现象（Phenomenon）<br>​<br>所以，可串行化但在具体技术实现上往往需要在并发能力和串行化效果之间进行平衡，很难两者兼顾。平衡的结果就是会出现违反串行效果的现象，即异常现象（Phenomenon）。</p><p>通常来说，隔离级别的提出就是性能和正确性的平衡，隔离级别越高，串行化效果越强，同时也伴随着并发能力的下降，两者负相关。</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1645760232142-20221130195201357.png" alt="img"></p><h2 id="隔离级别起源"><a href="#隔离级别起源" class="headerlink" title="隔离级别起源"></a>隔离级别起源</h2><p>在上一个章节中，我们讨论了隔离级别的本质，所谓隔离级别就是事务为了保证串行化效果的前提下均衡性能和一致性要求的结果。隔离级别越高，串行化效果越强，同时也伴随着并发能力的下降并同时出现异常现象（Phenomenon）,两者负相关。接下来我们来讨论个隔离级别的起源。</p><h1 id="隔离级别标准的提出"><a href="#隔离级别标准的提出" class="headerlink" title="隔离级别标准的提出"></a>隔离级别标准的提出</h1><p>首先，我们对比MysqlInnoDB引擎中的提供的四个隔离级别来入手。分别是：</p><ul><li>1）READ UNCOMMITTED (读未提交)；</li><li>2）READ COMMITTED （读已提交）；</li><li>3）REPEATABLE READ （可重复度）；</li><li>4）SERIALIZABLE （串行化执行）。</li></ul><p>这些知识在任何一部MySql教程中都有不少的介绍。这个标准是如何来的呢？ 事实上这些隔离级别其实并不是由MySql指定的，而是由一个组织名叫<strong>ANSI</strong>的组织制定的<strong>SQL-92</strong>标准。</p><p><strong>ANSI SQL-92</strong> 标准的第一版发布于 1986 年，之后又陆续发布了多个主版本和修订版本。不过，其影响最广泛的版本仍然是1992年发布的<strong>SQL-92</strong>，在这个版本中，<strong>ANSI</strong>组织总结了各种并发情况下可能出现的异常现象（<strong>Phenomenon</strong>），并给出了平衡的结果，并根据这些异常现象的容忍程度，这就是在上文提到的隔离级别。</p><p>这些隔离级别都是基于经典的序列化理论和是否允许三种异常现象（<strong>Phenomenon</strong>）（中文翻译就是我们熟知的脏读，不可重复度和幻读，注意这里是异常现象，并不是隔离级别）。这些现象有：</p><ul><li>(P1) Dirty Read （脏读）</li><li>(P2) Non-Repeatable Read （不可重复度）</li><li>(P3) Phantom （幻读）</li></ul><p>因此，根据对这些异常现象的容忍程度，给出了如下表格：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1642757861458-20221130195201635.png" alt="img"><br>(可以暂时认为P&#x3D;A)</p><h1 id="被质疑SQL-92标准"><a href="#被质疑SQL-92标准" class="headerlink" title="被质疑SQL-92标准"></a>被质疑SQL-92标准</h1><h2 id="标准的缺陷"><a href="#标准的缺陷" class="headerlink" title="标准的缺陷"></a>标准的缺陷</h2><p><strong>ANSI SQL-92</strong> 标准的出是想构建一个与实现无关，全面，理论话的标准，单是这个想法失败了。虽然针对于上述的三种异常现象<strong>ANSI SQL-92</strong> 给出了明确的定义。并且以这三种异常现象的有无来定义隔离级别。这显然是有些问题的。</p><ul><li>原因1：<strong>ANSI SQL-92</strong> 对这些异常现象给出的定义不够清晰和全面。</li></ul><p>作为标准，本应该由各大数据库厂商遵循并实现，但遗憾的是，在实际在实现过程中出现的异常现象远多于<strong>QL-92</strong>定义的现象，那么因此给出的隔离级别也会有所缺陷，甚至是错误。也正是因此，<strong>SQL-92</strong>的标准也开始被质疑。</p><ul><li>原因2：<strong>SQL-92</strong> 只考虑了数据是单个版本的情况下可能出现问题，并没有考数据可以有多个版本的情况。</li><li>原因3： <strong>ANSI SQL-92</strong> 是根据现象的容忍程度来定义标准，这显然是不符合理论的。</li></ul><p>上一篇文章我们从串行化理论入手来分析事务运行中的调度，来得出不同的调度会引起不同的异常现象。因此，想要定义完整的隔离级别，就必须从事务调度历史的依赖关系通过模型化的分析，才能得到科学全面的各级离别。<br>比如：<strong>ANSI SQL-92</strong> 规定避免P1、P2、P3异常现象就可以称之为可串行化了（what? 串行化理论够出一套教科书了，你告诉我避免P1-3就是串行化了？太儿戏了吧？）</p><p>即便如此，<strong>ANSI SQL-92</strong> 提出的观点至今为止仍然是应用最广的隔离级别定义, 但无论是当时还是后来都没有被各大数据库厂商严格遵循，部分原因可能是标准过于简化与实际应用有一定程度的脱离，这也是现在各大数据库厂商在隔离级别上的混乱的源头。</p><blockquote><p>如果想知道各大 RDBMS 厂商对事务隔离机制的实现的情况将参见:<a href="https://github.com/ept/hermitage">https://github.com/ept/hermitage</a></p></blockquote><h2 id="标准的批判"><a href="#标准的批判" class="headerlink" title="标准的批判"></a>标准的批判</h2><p>由于这个标准的各种不足，随后一篇著名的论文：<strong>「A Critique of ANSI SQL Isolation Levels」</strong> （以下简称<strong>Critique</strong>）横空出世，这篇文章提出了上述的三种缺陷，并对其做出了补充。（现在好多书籍，都是以这个论文提出的概念来讲解事务的。）但是并没有从本质上解决隔离级别定义的局限性。</p><p>随后，2000 <strong>「Generalized Isolation Level Definitions」</strong>这篇文章，指出了此前对隔离级别定义重度依赖数据库的实现，并且提出了与实现无关的隔离级别定义。这篇文章并没有从并发执行的事务产生的异常这个入手点分析，而是回归本质，通过事物之间的调度关系，从数学模型层面给出了科学的隔离级别的定义标准。这也是我们第一篇文章的理论依据。至此，隔离级别的争论才慢慢平息了下来。</p><p>但是，隔离级别的本质没有变化，还是性能和正确性之间的权衡。随着隔离级别多元化的理论发展下，各个数据库厂商的同名隔离级实现也大相径庭，没有做到标准规定那样。比如，MySQL 的 <strong>REPEATABLE READ</strong> 无法避免丢失更新（P4），(A5)读写偏序的问题（这两异常现象随后介绍），MVCC的实现也无法完全避免幻读（P3）异常等。也正因为如此，Mysql InnoDB的<strong>REPEATABLE READ</strong>被人狠狠的吐槽。</p><h2 id="标准的修订之路"><a href="#标准的修订之路" class="headerlink" title="标准的修订之路"></a>标准的修订之路</h2><p>接下来，我将用大量的篇幅介绍 <strong>「A Critique of ANSI SQL Isolation Levels」</strong> 这篇著名的论文，带你体会严谨的学术态度和数学建模的魅力所在。</p><p><strong>「Critique」</strong> 论文中，对<strong>SQL-92</strong>的隔离级别标准做了批判</p><p>第一，<strong>异常现象（Phenomenon）</strong>定义的模糊性：首先是自然语言方式界定的异常现象并不严格导致一些同质化的异常现象被遗漏；<br>第二、<strong>异常现象（Phenomenon）</strong>总结的不全面性。</p><p>ANSI当初制定标准时，依据的是<strong>single version（单版本）</strong> 和<strong>Lock schedule（锁调度）</strong>的思路，从最严格的 <strong>Serializable（由2PL实现）</strong>开始减少锁的数量、种类，放宽 <strong>release lock（释放锁）</strong> 的时机等，从而定义了4种隔离级别。但是事实上，在实现层面（Mysql）有类似多版本的实现方案（MVCC）。因此，仅仅从这两个方面定义的异常现象必定有所缺失。</p><p>因此，<strong>「Critique」</strong> 文中对<strong>SQL-92</strong>的三种异常现象由原来的（P1,P2,P3）重新将其编号为（A1&#x2F;A2&#x2F;A3）同时用公式来重新定义了A1,A2,A3并命名为新的（P1,P2,P3），又从中引申出了P0现象。并增加了两种锁实现中的可能异常（P4C和P4）和两种多版本并发控制实现中可能出现的异常（A5A和A5B），最后将所有这些异常组合在一起，并增加了两种隔离级别：<strong>Cursor Stability</strong>和 <strong>Snapshot</strong>。</p><p>接下来，我会深度分析 <strong>ANSI SQL-92</strong>，以及 <strong>「Critique」</strong> 中对其的补充修订。</p><h1 id="对SQL-92标准中的异常定义规范化"><a href="#对SQL-92标准中的异常定义规范化" class="headerlink" title="对SQL-92标准中的异常定义规范化"></a>对SQL-92标准中的异常定义规范化</h1><h2 id="ANSI-SQL-92-对Phantom的重新定义"><a href="#ANSI-SQL-92-对Phantom的重新定义" class="headerlink" title="ANSI SQL-92 对Phantom的重新定义"></a>ANSI SQL-92 对Phantom的重新定义</h2><p>再次强调，ANSI当初制定标准时，依据的是<strong>single version</strong> 和<strong>Lock schedule</strong>的思路，不存在多版本的情况。先来看<strong>ANSI SQL-92</strong> 标准中的可能导致三种数据出现的问题：</p><blockquote><ol><li>P1 (“Dirty read”): SQL-transaction T1 modifies a row. SQL-<br>transaction T2 then reads that row before T1 performs a COMMIT.<br>If T1 then performs a ROLLBACK, T2 will have read a row that was<br>never committed and that may thus be considered to have never<br>existed.</li></ol></blockquote><blockquote><ol><li>P2 (“Non-repeatable read”): SQL-transaction T1 reads a row. SQL-<br>transaction T2 then modifies or deletes that row and performs<br>a COMMIT. If T1 then attempts to reread the row, it may receive<br>the modified value or discover that the row has been deleted.</li></ol></blockquote><blockquote><ol><li>P3 (“Phantom”): SQL-transaction T1 reads the set of rows N<br>that satisfy some . SQL-transaction T2 then<br>executes SQL-statements that generate one or more rows that<br>satisfy the used by SQL-transaction T1. If<br>SQL-transaction T1 then repeats the initial read with the same<br>, it obtains a different collection of rows.</li></ol></blockquote><p>这一冗长的打算不容易理解，我们用公式化来理解。</p><p>为了能更清晰的表述事务之间的操作关系，我们将操作简化为 w(write)， r(read) ，每个操作的数字w1,r2代表执行操作的事务，例如 r1代表事务1读， w2代表事务2写。紧跟着操作的中括号[]的内容代表当前操作所涉及的资源，例如 w1[x] 代表事务1写入了资源x， r2[P] 代表事务2读取了满足谓词P的资源。最后，使用 c(commit) 和 a (abort) 来表示提交与回滚。</p><p>因此我们就可以用一连串的操作来表示一段操作历史：</p><blockquote><p>w1[x] … r2[x]…(a1 and c2 in any order): 可以按照顺序表述：</p></blockquote><ul><li>事务1执行w1[x]操作，</li><li>事务2执行r2[x]操作：</li><li>最后事务1回滚或事务2提交，且操作顺序无要求。</li></ul><p>因此，上述的P1-P3的定义为：</p><ul><li>P1: Dirty Read：w1[x] … r2[x] … (a1 and c2 in any order)</li><li>P2: Fuzzy Read：r1[x] … w2[x] … c2 … r1[x] … c1</li><li>p3: Phantom Read：r1[P] … w2[y in P] … c2 … r1[P] … c1</li></ul><p>这就是上文所对应的脏读，可重复度和幻读三个概念了。针对这个定义，我们来看一下其中的概念。</p><ul><li>r1[P]表示事务1按照谓词P的条件读取若干条记录</li><li>w1[y in P]表示事务1写入记录y满足谓词P的条件</li></ul><blockquote><p>谓词（predicate）虽然之前我们没有提及谓词这个概念，但其实大家已经使用过了。例如，&#x3D;、&lt;、&gt;、&lt;&gt; 等比较运算符，其正式的名称就是比较谓词。 我们可以简单理解为 SQL 语句Where 后面的表达式就好了。</p></blockquote><blockquote><p>通俗来讲谓词就是 各种各样的函数 中介绍的函数中的一种，是需要满足特定条件的函数，该条件就是返回值是真值。对通常的函数来说，返回值有可能是数字、字符串或者日期等，但是谓词的返回值全都是真值（TRUE&#x2F;FALSE&#x2F;UNKNOWN）。这也是谓词和函数的最大区别。</p></blockquote><p>根据定义，我们看到了P1的定义是T2读取提交后，T1恰好回滚之后，T2读取的值必定是T1回滚前的脏值。那么问题来了，异常的出现，我们一定要强调T1的回滚？其实不然，看一下的例子：</p><p>转账的例子：**: x &#x3D; 50; y &#x3D; 50 Txn1 从x向y转账40 **</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">r1[x, 50] w1[x &#x3D; 10](x - 40)</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">r2[x &#x3D; 10] r2[y &#x3D; 50]</td></tr><tr><td align="left">r1[y &#x3D; 50] w1[y &#x3D; 90](y &#x3D; y + 40)</td><td align="left"></td></tr><tr><td align="left">abort</td><td align="left">…</td></tr><tr><td align="left"></td><td align="left">commit</td></tr></tbody></table><p>可以看到，无论Txn1是否提交或者回滚，在某段时间范围内，不论Txn2是否提交或者回滚，读取到x + y ！&#x3D; 100。因此，对于P1的定义过于严格。</p><h2 id="重新定义P1、P2、P3"><a href="#重新定义P1、P2、P3" class="headerlink" title="重新定义P1、P2、P3"></a>重新定义P1、P2、P3</h2><p>因为 <strong>ANSI SQL-92</strong> 定义P1,P2,P3只有语言上的描述，没有准确的定义这些异常，所以 <strong>「Critique」</strong> 对其做了两种解释，用 P表明可能发生异常的现象，用 A 表示已经发生的异常。我举个栗子就明白了。<strong>SQL-92</strong>定P1的时候过于严格，当出现定义中满足的条件的时候，错误已经发生。<br>因此，我们将P1的定义用A1来描述，A1（一定出问题的意思）。 那么我对A1进行扩大解释，新的定义来替换原来的P1(表示可能发生异常)。 根据A1出问题的原因，我们不强调脏读一定发生在（提交，回滚）之后， 因此 这个P1的定义就出来了，我们对比A1来看下：</p><ul><li>P1: w1[x]…r2[x]…((c1 or a1) and (c2 or a2) in any order)</li><li>A1: w1[x]…r2[x]…(a1 and c2 in any order)</li></ul><blockquote><p>解释一下： 无论你T1提交还是回滚 T2在回滚和提交前，我已经读到你的脏值了，那么问题就会产生。</p></blockquote><p>还是上面转账的例子：</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">r1[x, 50] w1[x &#x3D; 10](x - 40)</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">r2[x &#x3D; 10] r2[y &#x3D; 50]</td></tr><tr><td align="left">r1[y &#x3D; 50] w1[y &#x3D; 90](y &#x3D; y + 40)</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>只要Txn2读到x &#x3D; 10(x &#x3D;10 是 Txn1中未提交的修改)就算脏读，不论是否有没有提交或者回滚。</p><p>根据这个规则，我们对原来的P2 和 P3 也类似的解释：</p><ul><li>P2: r1[x]…w2[x]…((c1 or a1) and (c2 or a2) in any order)</li><li>A2: r1[x]…w2[x]…c2…r1[x]…c1</li><li>P3: r1[P]…w2[y in P]…((c1 or a1) and (c2 or a2) any order)</li><li>A3: r1[P]…w2[y in P]…c2…r1[P]…c1</li></ul><p>有些文章将A系列(<strong>ANSI SQL-92</strong> 定义的异常现象)叫做狭义解释（严格解释），把P系列（ <strong>Critique</strong> 优化A系列定义的异常现象）叫做广义解释（宽泛解释）。</p><h2 id="P3（幻读的坑）的补充"><a href="#P3（幻读的坑）的补充" class="headerlink" title="P3（幻读的坑）的补充"></a>P3（幻读的坑）的补充</h2><p>A3名叫幻读，在幻读问题上，它和P2有着混淆的一个概念，首先我们先来看 <strong>ANSI SQL-92</strong> 定义的幻读:</p><blockquote><p>(“Phantom”): SQL-transaction T1 reads the set of rows N<br>that satisfy some . SQL-transaction T2 then<br>executes SQL-statements that generate one or more rows that<br>satisfy the used by SQL-transaction T1. If<br>SQL-transaction T1 then repeats the initial read with the same<br>, it obtains a different collection of rows.</p></blockquote><p>翻译一下：</p><ul><li>事务 T1 读取一组满足某些 &lt;搜索条件&gt; 的数据。</li><li>事务 T2 创建了满足 T1 的 &lt;搜索条件&gt; 的数据项并提交。</li><li>如果 T1 用相同的&lt;搜索条件&gt;再次读取，得到一组不同于第一次读取的数据。这就叫幻读。</li></ul><p>例子如下:</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,3,4]</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">begin</td></tr><tr><td align="left">…</td><td align="left">insert into t(a) values (2);</td></tr><tr><td align="left"></td><td align="left">commit</td></tr><tr><td align="left">select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,2,3,4]</td><td align="left"></td></tr></tbody></table><p>我们可以看到， Txn1最后获取到结果比原来的多一行。 也即是说，我们第一次读和第二次读取结果应该一样，都应该是2，3，4。这个定义怎么这么像 A2(<strong>SQL-92中的P2</strong>)（不可重复度）被？我们再来拿A2的定义看一下：</p><blockquote><p>P2(A2) (Non-repeatable or Fuzzy Read): Transaction T1 reads a data item. Another transaction T2 then modifies or deletes that data item and commits. If T1 then attempts to reread the data item, it receives a modified value or discovers that the data item has been deleted.</p></blockquote><p>注意和幻读定义的两个不同：</p><ul><li>幻读定义中有 &lt; search condition &gt;</li><li>幻读定义中 T2 是“创建数据”，不可重复读的定义中 T2 是修改或者删除数据</li></ul><p>在满足 **&lt; search condition &gt; **的范围内，修改和删除数据必定是对已经存在的数据行操作，而创建数据则意味着创建之前这个数据项是不存在的。“创建数据”不仅是 insert，还包括 update。update 把本来不满足谓词范围的数据项更新成满足谓词范围的数据项，比如：谓词范围是 a&gt;1 and a&lt;5，update a&#x3D;2 where a&#x3D;6 就是这样的情况。</p><p>显然，这样定义幻读是不合适的。对于A3和扩展P3的来说</p><ul><li>P3: r1[P]…w2[y in P]…((c1 or a1) and (c2 or a2) any order)</li><li>A3: r1[P]…w2[y in P]…c2…r1[P]…c1</li></ul><p>A3 的定义强调Txn2 提交后 r1 再去查询谓词，得到结果集不符合才算是幻读。这样是有问题的，下看面的例子：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">//tt是员工表</span><br><span class="hljs-section">mysql&gt; select * from tt;</span><br><span class="hljs-section">+----------+------------+</span><br><span class="hljs-section">| name     | department |</span><br><span class="hljs-section">+----------+------------+</span><br>| zhangsan | developer  |<br><span class="hljs-section">| lisi     | developer  |</span><br><span class="hljs-section">+----------+------------+</span><br>2 rows in set (0.00 sec)<br><br><span class="hljs-comment">//tt_count是各部门人数统计表</span><br><span class="hljs-section">mysql&gt; select * from tt_count;</span><br><span class="hljs-section">+------------+--------+</span><br><span class="hljs-section">| department | number |</span><br><span class="hljs-section">+------------+--------+</span><br><span class="hljs-section">| developer  |      2 |</span><br><span class="hljs-section">+------------+--------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>查询序列</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">select name from tt where department &#x3D; ‘developer’ )[zhangsan,lisi ]</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">begin</td></tr><tr><td align="left">…</td><td align="left">insert tt(name, department) values(‘wangwu’,‘developer’);</td></tr><tr><td align="left">…</td><td align="left">update tt_count set number &#x3D; number + 1 where department &#x3D; ‘developer’</td></tr><tr><td align="left"></td><td align="left">commit</td></tr><tr><td align="left">select number from tt_count where department &#x3D; ‘developer’ )[3 ]</td><td align="left"></td></tr><tr><td align="left">commit</td><td align="left"></td></tr></tbody></table><p>上述的例子当中，Txn1 并没有去查询所谓的谓词，但是依然出现了tt_count表中的 <code>developer 的number = 3</code>, 因此，按照A3的定义来说是有问题的，如果我们用P3广义的来解释，只要 <code>insert tt(name, department) values(&#39;wangwu&#39;,&#39;developer&#39;)</code> 这条语句成功，那就算是幻读了。这样是可以解释通的。</p><p>这也是 P3 定义的由来，只要事务2对事务1的谓词范围进行了写入（写入成功），不管后面事务1做什么查询，都算是幻读。</p><p>幻读的另外一个例子：</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,3,4]</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">begin</td></tr><tr><td align="left">…</td><td align="left">update set a &#x3D; 2 where a &#x3D; 6);</td></tr><tr><td align="left"></td><td align="left">commit</td></tr><tr><td align="left">select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,2,3,4]</td><td align="left"></td></tr></tbody></table><p>再直观点讲（个人解读），不可重复读是说读的结果的行数不变或者减少，结果的内容发生变化；而幻读呢，就是读的结果的行数变多了。这就是<strong>SQL-92</strong> 定义的幻读。但是<strong>Critique</strong>认为这样定义幻读是不对的，论文认为幻读强调的是两次相同查询不同的数据，因此把删除一行，也就是数据变少，也应该属于幻读行列。</p><p>具体原文如下：</p><blockquote><p>One important note is that ANSI SQL P3 only prohibits inserts (and updates, according to some interpretations) to a predicate whereas the definition of P3 above prohibits any write satisfying the predicate once the predicate has been read — the write could be an insert, update, or delete.</p></blockquote><p>有了幻读较少数据的这个补充，我们来讨论另外一个case:</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">select a from t where a &#x3D; 1)[result:2]</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">begin</td></tr><tr><td align="left">…</td><td align="left">delete from t where a &#x3D; 1);</td></tr><tr><td align="left"></td><td align="left">commit</td></tr><tr><td align="left">select a from t where a &#x3D; 1)[result:[]</td><td align="left"></td></tr></tbody></table><p>按照谓词查询一个数据，按照上面说的<strong>Critique</strong> 对P3的定义，这个case应该不仅满足P3也同时满足P2,那么问题又来了，这到底算是那个case?<br>在标准中有如下定义：</p><blockquote><p>p2 Another transaction T2 then modifies or <strong>deletes</strong> that data item</p></blockquote><blockquote><p>p3 the write could be an insert, update, or <strong>delete</strong></p></blockquote><p>由于标准中幻读和脏读的定义中核心点的区分就是，一个是 date item 的变化，一个是对Data Set的变化，上面的case可以有两种解读, 就是返回的结果是一个 data item 还是一个 data set？</p><p>根据前文知道，a &#x3D; 1 在where之后，可以理解为谓词：Predicate， 严格来说，所有的查询条件都属于谓词；而相对的，在 KV 存储引擎中直接读取某个 key 的行为则称为 item。然而关系型数据库在 KV 之上还有 SQL 层，SQL 层即使是读取某个 key 也是通过一些查询条件（predicate）来进行描述的，当我们在 SQL 层面之上讨论是 predicate 还是 item 的时候，需要考虑它是否是一个点查询。</p><p>点查询是一种查找数据的方法，通过建立好的索引去定位数据的 key，一般能够用非常高的效率查找到所需的数据，其查询的过程和读取某个 key 相似，所以本文的观点认为：点查询是第一次查询返回为data item类型的查询。其他查询均是 predicate 类型的查询条件。明白这个之后，我们可以回答这个问题：上面的case是不P2。</p><p>当三个原始异常的坑填补上之后，我们再来看隔离级别：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1642757861458-20221130195201635.png" alt="img"></p><h4 id="增加P0"><a href="#增加P0" class="headerlink" title="增加P0"></a>增加P0</h4><p><strong>ANSI SQL-92</strong> 在定义异常的时候忽略了一个比较低级的异常现象， 先看定义：</p><ul><li>P0: w1[x]…w2[x]…((c1 or a1) and (c2 or a2) in any order)</li></ul><p>看一下例子：</p><table><thead><tr><th align="left">Txn1</th><th align="left">Txn2</th></tr></thead><tbody><tr><td align="left">begin</td><td align="left"></td></tr><tr><td align="left">w(x,2)</td><td align="left"></td></tr><tr><td align="left">…</td><td align="left">begin</td></tr><tr><td align="left">…</td><td align="left">w(x,3)</td></tr><tr><td align="left"></td><td align="left">…</td></tr><tr><td align="left">commit(abort)</td><td align="left"></td></tr></tbody></table><p>T1写入和提交之间，T2趁机写入别的的数据。能带来的后果为两个，导致T1的更新丢失了（没错，脏写有时候会被归为丢失更新。）</p><ul><li>1、不能保证数据的一致性。</li><li>2、回滚异常（设定x初始值为0， 当T1发生异常要回滚，是回滚到3还是回滚到0？）</li></ul><p>讲到这里你获取会奇怪，两个事务同时写X。同时写X加锁不就好了？管谁写，写成功就好了，为啥这也定义？是的，如果给x记上锁，那就意味着我想对这个序列串行化处理，串行化是我们后边隔离级别要讨论的事情，我们这里只谈问题，不谈解决办法，毕竟只有知道有问题在哪，我们才能解决不是。</p><h3 id="重新定义隔离级别"><a href="#重新定义隔离级别" class="headerlink" title="重新定义隔离级别"></a>重新定义隔离级别</h3><p>至此，四个新的定义出现了, 注意这里一个点，就是删掉了c2和a2,既然我们不强第二个调事务终止，所以就没有必要强调第二个事务提交或者回滚。但是我们必须要保留第一个事务的提交或者回滚，来却确保一个事务的操作会影响另一个事务操作。</p><ul><li>P0: w1[x]…w2[x]…(c1 or a1) (Dirty Write)</li><li>P1: w1[x]…r2[x]…(c1 or a1) (Dirty Read)</li><li>P2: r1[x]…w2[x]…(c1 or a1) (Fuzzy or Non-Repeatable Read)</li><li>P3: r1[P]…w2[y in P]…(c1 or a1) (Phantom)</li></ul><p>并且用广义的定义重新描述了ANSI隔离级别：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/distributed-transaction-1-1642766870162-20221130195201719.png" alt="img"></p><p>然后根据P0-P3的容忍度补充了标准内的隔离级别。根据上面的新定义的图示，有了PO之后，感觉这个标准更加完善了，但是依旧有些异常现象不在这四种之内，比如<strong>P4,P4C</strong>之类的。我们下一篇文章在谈论。</p><p>下一篇文章，我会根据基于ANSI锁调度，分析上表中的隔离级别是如何实现的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.modb.pro/db/88214">关于 MySQL Repeatable Read Isolation 常见的三个误区</a></li><li><a href="https://www.cnblogs.com/ivan-uno/p/8274355.html">再谈数据库事务隔离性</a></li><li><a href="https://juejin.cn/post/6844903854857781262">Mysql RR级别依然可能丢失更新数据</a></li><li><a href="https://segmentfault.com/a/1190000023045329">事务隔离级别，看这一篇就够了</a></li><li><a href="https://pingcap.com/zh/blog/take-you-through-the-isolation-level-of-tidb-1">Transaction management：两阶段锁（two-phase locking</a></li><li><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.225.2581&rep=rep1&type=pdf">Correctness Criteria Beyond Serializability</a></li><li><a href="https://hw311.me/zh/study-notes/database/2019/02/24/transaction-consistency-serializability/#fn:1">Transaction management：可串行性（serializability）</a></li><li><a href="https://lenshood.github.io/2020/11/30/isolation-level-with-mysql/">MySQL(InnoDB) 独特的 Repeatable Read 隔离级别</a></li><li><a href="http://blog.kongfy.com/2019/03/serializable/">可串行化（Serializable）：理想和现实</a></li><li><a href="https://segmentfault.com/a/1190000040548324">技术分享 | 隔离级别：正确理解幻读</a></li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a></li><li><a href="https://niceaz.com/2019/03/24/isolation-2pl-mvcc/">数据库的隔离级别与2PL&#x2F;MVCC算法原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/369953647">《A Critique of ANSI SQL Isolation Levels》论文导读</a></li><li><a href="https://zz-jason.github.io/posts/ansi-sql-isolation-levels/">论文阅读：《A Critique of ANSI SQL Isolation Levels》</a></li><li><a href="http://oserror.com/backend/transaction-isolation-second/">事务隔离（二）：基于加锁方式的事务隔离原理</a></li><li><a href="https://blog.csdn.net/matrixyy/article/details/43115589">数据库事务的ACID隔离级中P0（脏写）和P4（更新丢失）的区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/11/database/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-B+Tree/"/>
    <url>/2022/07/11/database/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-B+Tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://awesome-programming-books.github.io/mysql/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.pdf">https://awesome-programming-books.github.io/mysql/MySQL技术内幕：InnoDB存储引擎.pdf</a></p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220711200810.png"></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220711200932.png"><br>。。。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220711201148.png"></p><p>一开始如下图：<br><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220711201346.png"></p><p>删除70，直接删掉即可：<br><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220711201454.png"></p><p>删除25，</p><p>目前无法restore project的error message和‘现在正有一个项目部署’的error message一样，所以前端无法区分。给前者换一个error message</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">&#123;</span>data<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span> errors<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">,</span>…<span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br><br>data<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span>  <br>errors<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">,</span>…<span class="hljs-punctuation">]</span>  <br><span class="hljs-number">0</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>errorCode<span class="hljs-punctuation">:</span> <span class="hljs-number">403</span><span class="hljs-punctuation">,</span> errorType<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INVALID_DEPLOYMENT&quot;</span><span class="hljs-punctuation">,</span> extensions<span class="hljs-punctuation">:</span><br><br><span class="hljs-punctuation">&#123;</span>classification<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INVALID_DEPLOYMENT&quot;</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">,</span>…<span class="hljs-punctuation">&#125;</span>  <br>errorCode<span class="hljs-punctuation">:</span> <span class="hljs-number">403</span>  <br>errorType<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INVALID_DEPLOYMENT&quot;</span>  <br>extensions<span class="hljs-punctuation">:</span><br><br><span class="hljs-punctuation">&#123;</span>classification<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INVALID_DEPLOYMENT&quot;</span><span class="hljs-punctuation">&#125;</span><br><br>classification<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INVALID_DEPLOYMENT&quot;</span>  <br>locations<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><br><span class="hljs-punctuation">&#123;</span>column<span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> line<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">]</span>  <br><span class="hljs-number">0</span><span class="hljs-punctuation">:</span><br><br><span class="hljs-punctuation">&#123;</span>column<span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> line<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><br><br>message<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cannot deploy project when deployment env config status is RESTORE_FAILED&quot;</span>  <br>operation<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;deploy&quot;</span>  <br>path<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;deploy&quot;</span><span class="hljs-punctuation">]</span>  <br><span class="hljs-number">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;deploy&quot;</span>  <br></code></pre></td></tr></table></figure><p>需要改成BROKEN_DEPLOYMENT</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/28/database/15445-B+Tree1/"/>
    <url>/2022/06/28/database/15445-B+Tree1/</url>
    
    <content type="html"><![CDATA[<ul><li><p>目前为止，我还没有⻅过一个系统中说过它们用的是B-T ree(B树)。postgresql虽然说是使用B-Tree，但实际上还是B+树。 所以实际上有时候不会那么严谨，B-Tree和B+Tree可以交替使用</p></li><li><p>在任何inner node中，它们并没有兄弟指针(sibling pointer)，但叶子节点有 （在mysql中，page header中有前后pageId）</p></li><li><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/image-20220628192142510.png"></p><p>一般都是kv分开存的：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/image-20220628192255107.png" alt="image-20220628192255107"></p><p>这样的好处是，当你对它进行二分查找的时候，CPU缓存命中率更高。</p></li><li><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/image-20220628192843240.png" alt="image-20220628192843240"></p></li></ul><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><ol><li>Find correct leaf L.</li><li>Add new entry into L in sorted order:<br>• If L has enough space, the operation done.<br>• Otherwise split L into two nodes L and L2. Redistribute entries evenly and copy up middle key.<br>Insert index entry pointing to L2 into parent of L.</li><li>To split an inner node, redistribute entries evenly, but push up the middle key</li></ol><h2 id="detele"><a href="#detele" class="headerlink" title="detele"></a>detele</h2><ol><li>Find correct leaf L.</li><li>Remove the entry:<br>• If L is at least half full, the operation is done.<br>• Otherwise, you can try to redistribute, borrowing from sibling. （从兄弟节点中借）<br>• If redistribution fails, merge L and sibling. （借不到，那么需要和兄弟节点合并）</li><li>If merge occurred, you must delete entry in parent pointing to L.</li></ol>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/24/database/A%20Critique%20of%20ANSI%20SQL%20Isolation%20Levels/"/>
    <url>/2022/06/24/database/A%20Critique%20of%20ANSI%20SQL%20Isolation%20Levels/</url>
    
    <content type="html"><![CDATA[<p>#database #blog #isolation #reading</p><p><a href="https://blog.acolyer.org/2016/02/24/a-critique-of-ansi-sql-isolation-levels/">https://blog.acolyer.org/2016/02/24/a-critique-of-ansi-sql-isolation-levels/</a></p><blockquote><p>#read-list</p><ul><li><a href="https://blog.acolyer.org/2016/01/05/granularity-of-locks/">https://blog.acolyer.org/2016/01/05/granularity-of-locks/</a></li><li><a href="https://blog.acolyer.org/2016/01/06/degree-of-consistency/">https://blog.acolyer.org/2016/01/06/degree-of-consistency/</a></li><li><a href="https://blog.acolyer.org/2016/02/25/generalized-isolation-level-definitions/">https://blog.acolyer.org/2016/02/25/generalized-isolation-level-definitions/</a></li><li><a href="https://blog.acolyer.org/2016/01/08/aries/">https://blog.acolyer.org/2016/01/08/aries/</a></li></ul></blockquote><p>ANSI SQL 隔离级别最初是以散文的形式定义的，它们是根据设计用来防止的三种特定异常情况来定义的。这些最初的定义有些模棱两可，可以作出严格和宽泛的解释。事实证明它们还不够，因为标准中还有一个更基本的异常没有提到，需要加以防止，以便能够实现回滚和恢复。</p><p>更深入地看，本文揭示了可能发生的八种不同的现象(异常)和六种不同的隔离级别。在这篇文章中，我将重点解释这些现象和隔离级别，对于那些对原始 ANSI SQL 隔离级别的详细比较感兴趣的人，请参阅全文 —— <a href="http://arxiv.org/pdf/cs/0701157.pdf">A Critique of ANSI SQL Isolation Levels</a> – Berenson et al. 1995</p><img src="https://blog.acolyer.org/wp-content/uploads/2016/02/ansi-sql-isolation-levels.png" alt="img" style="zoom:30%;" /><p>在接下里的描述中，<code>long duration lock</code> <strong>（长期锁）是那些一直持有到事务结束的锁</strong>，而<code>short duration locks</code><strong>（短期锁）则在所涉及的操作完成后释放</strong>。 <strong>基于谓词的查询</strong>是指<code>select ... where ...</code></p><h3 id="Phenomena"><a href="#Phenomena" class="headerlink" title="Phenomena"></a>Phenomena</h3><h4 id="P0-Dirty-Write-脏写"><a href="#P0-Dirty-Write-脏写" class="headerlink" title="P0: Dirty Write 脏写"></a>P0: Dirty Write 脏写</h4><p>A <em>Dirty Write</em> occurs when one transaction overwrites a value that has previously been written by another still in-flight transaction.  当一个事务覆盖了一个先前被另一个<strong>仍在运行的事务</strong>写入的值时，就会发生脏写。 (就是说，事务A在改这个值，事务B也在改这个值)</p><p>One reason why Dirty Writes are bad is that they can violate database consistency. Assume there is a constraint between x and y (e.g., x &#x3D; y), and T1 and T2 each maintain the consistency of the constraint if run alone. However, the constraint can easily be violated if the two transactions write x and y in different orders, which can only happen if there are Dirty writes.</p><p>Dirty Writes糟糕的一个原因是，它们会违反<strong>数据库的一致性</strong>。假设在x和y之间有一个约束（例如，<strong>x&#x3D;y</strong>），T1和T2如果单独运行，都能保持约束的一致性。然而，如果两个事务以不同的顺序写入x和y，那么这个约束很容易被违反，这只有在存在Dirty writes的情况下才会发生。</p><p>假设 T1写入 x &#x3D; y &#x3D; 1，T2写入 x &#x3D; y &#x3D; 2，下面的流程违反了完整性约束：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/dirty-write.png" alt="img"></p><p>t1(x&#x3D;1) -&gt; t2(x&#x3D;2) -&gt; t2(y&#x3D;2) -&gt; t1(y&#x3D;1) ， 结果x&#x3D;2 &amp; y &#x3D; 1</p><p>Dirty Writes糟糕的另一个原因是，如果不防止脏写操作，系统就不能在<strong>事务中止时自动回滚到 before 映像</strong> （因为T1如果回滚的话，会把T2的修改也撤销掉，丢失了数据）</p><p>因此，基本上所有数据库都会持有<strong>长期的写锁</strong></p><blockquote><p>ANSI SQL 居然没有定义这样一种基本的异常 …</p></blockquote><h4 id="P1-Dirty-Read-脏读"><a href="#P1-Dirty-Read-脏读" class="headerlink" title="P1: Dirty Read 脏读"></a>P1: Dirty Read 脏读</h4><p>当<strong>一个事务读取另一个仍在运行的事务写入的值</strong>时，就会发生脏读。</p><p>那个<strong>写的事务B无论最终是提交还是回滚，读的事务A都不应该读到这个数据</strong></p><p><strong>短期的读锁 + 长期的写锁</strong>  可以解决这个脏读的问题，证明如下：</p><blockquote><p>因为这样，事务A select的时候需要拿到读锁：</p><ul><li>如果拿到了，说明此时没有人有写锁，所以此时去读的话是正确的</li><li>如果没拿到，说明此时事务B拿着写锁，所以此时去读的话是拿不到读锁的，所以会等事务B提交后，才能拿到读锁。 无论B是提交还是回滚，A拿到读锁后读的值就是正确的。</li></ul><p>简而言之，这种形式可以保证A读的时候，没有B事务中去写.</p></blockquote><h4 id="P2-Non-Repeatable-Read-不可重复读"><a href="#P2-Non-Repeatable-Read-不可重复读" class="headerlink" title="P2: Non-Repeatable Read 不可重复读"></a>P2: Non-Repeatable Read 不可重复读</h4><p>当一个仍在运行的事务已经读取的值被另一个事务<strong>覆盖</strong>时，就会发生不可重复读。</p><p>解决脏读是避免了读事务begin后select前，有一个写事务改了数据还没提交。 而解决不可重复读是避免了一个事务内前后两次读结果不一样，就是使得事务A<strong>第一次select后就给这些数据加锁，其他事务就不能去修改这些数据</strong>，这样事务A第二次select就可以拿到相同的结果。</p><h4 id="P3-Phantom-Read-幻读"><a href="#P3-Phantom-Read-幻读" class="headerlink" title="P3: Phantom Read 幻读"></a>P3: Phantom Read 幻读</h4><p>幻读从概念上是不可重复读的一种，也是前后两次读的结果相同，但是从实现上差很多，因而单独作为一种类型：</p><ul><li>对于前者,  只需要锁住满足条件的记录，即加<strong>行锁</strong></li><li>对于后者,  要<strong>锁住满足条件及其相近的记录</strong>，即加<strong>表锁</strong> （我感觉也不一定要加表锁吧？也可以加某种锁，保证不会有新的数据进入这个范围，也没有这个范围的数据被删除（或者通过更新来脱离这个范围））</li></ul><p>当一个事务执行基于谓词的读(例如 SELECT… WHERE P) ，而另一个事务在第一个事务仍在运行时写入与该谓词（where）匹配的数据项时，就会出现“幻影”。在最初的 ANSI SQL 语言中，只有匹配的插入是被禁止的(新的条目是幻影) 。但实际上，我们需要禁止任何写: <strong>更新、删除和插入。</strong> （因为都有可能导致幻读）:</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/phantom.png" alt="img"></p><h4 id="P4"><a href="#P4" class="headerlink" title="P4:"></a>P4:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> hello;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/24/database/database%20lock/"/>
    <url>/2022/06/24/database/database%20lock/</url>
    
    <content type="html"><![CDATA[<p>#wikipedia #database #lock<br><a href="https://en.wikipedia.org/wiki/Record_locking">https://en.wikipedia.org/wiki/Record_locking</a></p><h1 id="Record-locking"><a href="#Record-locking" class="headerlink" title="Record locking"></a>Record locking</h1><p><strong>Record locking</strong> (锁定记录)是为了防止并发访问时的不一致而诞生的</p><p>典型的例子是两个银行职员试图为两个不同的交易<strong>更新同一个银行账户</strong>，比如职员1给这个账户扣100元，职员2为这个账户扣200元。 职员1和职员2都拿到初始钱为500元，职员1扣了100元提交，此时是400元。由于职员2拿到的是旧数据，所以职员2扣了200元提交，此时是300元。这样就少扣了100元。</p><p>为了避免这种不一致，在检索一条记录进行更新时可以<strong>锁定该记录</strong>，任何试图查询这个记录并更新的人都会因为锁而被拒绝写访问。一旦记录保存或者rollback，锁就会释放。</p><h1 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h1><p>当使用 <em>incremental locking</em>  （增量锁定：即先锁定一个，再逐步锁定第二个…）时，死锁是可能的。</p><p>例如：如果A用户要转给B用户100，B用户要转给A用户两百，这是两个并发sql。A用户执行时，先要拿到A用户的原始值，所以A被锁定。B用户执行时，也需要拿到B的原始值，所以B锁定。<strong>此时，这两个帐户是锁定的</strong>。  然后，A用户扣了100元，想要给B用户+100时，发现B上锁了；而B也发现A上锁了。因而死锁了。</p><p>所以，在数据库中，还要注意避免死锁的问题。</p><h1 id="Use-of-locks"><a href="#Use-of-locks" class="headerlink" title="Use of locks"></a>Use of locks</h1><p>有两种主要的🔒：</p><p><strong>共享锁 (Shared lock)，又称之为读锁，简称S锁</strong>，当事务对数据加上读锁后，<strong>其他事务只能对该数据加读锁，不能做任何修改操作</strong>，也就是<strong>不能添加写锁</strong>。只有当数据上的读锁被释放后，其他事务才能对其添加写锁。共享锁主要是为了支持并发的读取数据而出现的，读取数据时，<strong>不允许其他事务对当前数据进行修改操作</strong>。</p><p><strong>排它锁 (Exclusive lock)，又称之为写锁，简称X锁</strong>，当事务对数据加上写锁后，其他事务<strong>既不能对该数据添加读锁，也不能对该数据添加写锁</strong>，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。</p><blockquote><p>之所以能解决脏读，是因为写的时候不能有人在读写，所以读到的肯定是之前就提交的数据，当前某个事务正在改的话，是拿不到读锁的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/24/database/database%20isolation/"/>
    <url>/2022/06/24/database/database%20isolation/</url>
    
    <content type="html"><![CDATA[<p>#wikipedia #database #isolation</p><h1 id="Concurrency-control"><a href="#Concurrency-control" class="headerlink" title="Concurrency control"></a>Concurrency control</h1><p><a href="https://en.wikipedia.org/wiki/Concurrency_control" title="Concurrency control">Concurrency control</a> 并发控制，数据库和存储引擎大量使用它来保证并发事务的正确执行。<br><a href="https://en.wikipedia.org/wiki/Two-phase_locking" title="Two-phase locking">Two-phase locking</a> 两阶段锁并发控制是数据库管理系统中最常用的事务处理方法，用于提供序列化(serializability)和可恢复性(recoverability)以保证正确性。 为了访问数据库对象，<strong>事务首先需要获取该对象的锁</strong>。根据访问操作类型(例如读或写对象)和锁类型，如果另一个事务持有该对象的锁[[database lock]]，则获取锁可能会被阻塞和延迟。</p><h1 id="Read-phenomena-异象"><a href="#Read-phenomena-异象" class="headerlink" title="Read phenomena 异象"></a>Read phenomena 异象</h1><p>ANSI&#x2F;ISO 标准 SQL 92引用了三种不同的异象（当事务1读取事务2可能已经更改的数据时）<br>在下面的示例中，发生了两个事务。首先，第一个事务执行查询1。然后，在第二个事务中，执行并提交查询2。最后，在第一个事务中，再次执行查询1。</p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/image-20220624144549724.png" alt="image-20220624144549724" style="zoom:50%;" /><h2 id="Dirty-Read"><a href="#Dirty-Read" class="headerlink" title="Dirty Read"></a>Dirty Read</h2><p>当事务中读到另一个事务中还没提交的值时，就是脏读。<br><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220624144827.png" style="zoom:50%;" /></p><h2 id="Non-repeatable-reads"><a href="#Non-repeatable-reads" class="headerlink" title="Non-repeatable reads"></a>Non-repeatable reads</h2><p>在一个事务中，前后两次select的结果不一样，就叫不可重复读</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220624162157.png"></p><p>有两种基本策略用于防止不可重复读取。</p><ol><li>第一种方法是延迟事务2的执行，直到事务1提交或回滚。该方法在使用锁时使用，并产生串行调度 T1，T2</li><li>用MVCC机制来解决，事务2允许先提交，但是在事务2前begin的事务1读到的必须是事务开始前的值，这是快照。 (当事务1最终试图提交时，DBMS检查提交事务1的结果是否等同于T1、T2串行化。如果是，那么事务1可以继续。然而，如果不是，事务1必须回滚)</li></ol><h2 id="Phantom-reads-幻读"><a href="#Phantom-reads-幻读" class="headerlink" title="Phantom reads 幻读"></a>Phantom reads 幻读</h2><p>A <em>phantom read</em> occurs when, in the course of a transaction, new rows are added or removed by another transaction to the records being read. 当在事务过程中，另一个事务向正在读取的记录<strong>添加或删除新行</strong>时，就会发生幻读。</p><p>如果在执行 SELECT… WHERE 操作时未获得范围锁，则可能发生这种情况。幻读异常是一种<strong>特殊的不可重复读取情况</strong>，当 Transaction 1重复一个范围内的 SELECT… WHERE 查询时，在两个操作之间，Transaction 2创建一个范围内的(即 INSERT)新行 </p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/20220624164049.png"></p><p>如果在最高隔离级别的串形化中，两次应该返回相同的row set，然而在隔离级别较低的情况下，两次可能返回不同的row set。<br>（在 SERIALIZABLE 隔离模式中，查询1将导致锁定范围在10到30之间的所有记录，因此查询2将阻塞直到提交第一个事务； 在 REPEATABLE READ 模式下，范围不会被锁定，允许插入记录。因此，查询1的第二条语句不会返回与第一条语句相同的结果）</p><h1 id="Isolation-levels-隔离级别"><a href="#Isolation-levels-隔离级别" class="headerlink" title="Isolation levels 隔离级别"></a>Isolation levels 隔离级别</h1><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>这是最高的隔离级别。</p><p>使用基于锁的并发控制的DBMS，序列化需要在<strong>事务结束时释放读写锁</strong>(🔒在select时获取)。 此外，当 SELECT 查询使用范围 WHERE 子句时，必须获得<strong>范围锁</strong>，特别是为了避免幻像读取现象。</p><p>当使用基于non-lock的并发控制时，不会获得锁，但是，如果系统检测到多个并发事务之间的写冲突，则只允许其中一个事务提交。有关此主题的详细信息，参阅快照隔离 _<a href="https://en.wikipedia.org/wiki/Snapshot_isolation" title="Snapshot isolation">snapshot isolation</a>_。</p><h2 id="Repeatable-reads"><a href="#Repeatable-reads" class="headerlink" title="Repeatable reads"></a>Repeatable reads</h2><p>在这个隔离级别中，基于锁的并发控制数据库管理系统实现会一直保持读写锁(在select的数据上获取) ，直到事务结束。但是，不管理范围锁，因此可能发生幻读。</p><p>在某些系统中，在这个隔离级别上可能出现写偏移。写偏移是一种现象，即允许两个不同的写入者（他们之前已经读过他们要更新的列）对<strong>表中的同一列进行两次写入</strong>，导致该列的数据是两个事务的混合。</p><h2 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h2><p>在这个隔离级别中，基于锁的并发控制的DBMS会<strong>保持写锁</strong>(在选定的数据上获取)<strong>直到事务结束</strong>，但是<strong>一旦执行了 SELECT 操作，读锁就会被释放</strong>(因此在这个隔离级别中可能会出现<strong>不可重复的读</strong>现象)。与前一级别一样，范围锁不受管理。</p><blockquote><p>每次写的事务都会一直持有这个写锁，因此不会脏读</p></blockquote><h2 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h2><p>这是最低隔离级别。在这个级别中，允许进行脏读操作，因此一个事务可能会看到其他事务所做的尚未提交的更改。</p><h1 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h1><p>不同 DBMS 的默认隔离级别差异很大。大多数具有事务特性的数据库允许用户设置任何隔离级别。有些 DBMS 在执行 SELECT 语句以获取锁时还需要额外的语法(例如，SELECT… FOR UPDATE 以获取<strong>被访问行上的独占写锁</strong>)。</p><p>但是，这三个 ANSI phenomena 有一定的歧义。。。。</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库隔离发展历史</title>
    <link href="/2022/06/24/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/"/>
    <url>/2022/06/24/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<p>#database #isolation #blog&#x2F;reading</p><p><a href="https://catkang.github.io/2018/08/31/isolation-level.html">https://catkang.github.io/2018/08/31/isolation-level.html</a></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>事务隔离是事务并发产生的直接需求，最直观的、保证正确性的隔离方式，显然是让并发的事务依次执行，或是看起来像是依次执行。但在真实的场景中，有时并不需要如此高的正确性保证，因此希望牺牲一些正确性来提高整体性能。<strong>通过区别不同强度的隔离级别使得使用者可以在正确性和性能上自由权衡。随着数据库产品数量以及使用场景的膨胀，带来了各种隔离级别选择的混乱，数据库的众多设计者和使用者亟需一个对隔离级别划分的共识，这就是标准出现的意义。一个好的隔离级别定义有如下两个重要的目标</strong>：</p><ul><li><strong>正确</strong>：每个级别的定义，应该能够将所<strong>有损害该级别想要保证的正确性的情况排除在外</strong>。也就是说，只要实现满足某一隔离级别定义，就一定能获得<strong>对应的正确性保证</strong>。</li><li><strong>实现无关</strong>：常见的并发控制的实现方式包括，锁、OCC以及多版本 。而一个好的标准不应该限制其实现方式。</li></ul><blockquote><p>所以，事务隔离的目标就是尽量让并发的事务看起来像是依次执行的。 真实的情况往往会牺牲一些正确性来提升性能，因而就有了很多种隔离级别。</p></blockquote><h1 id="ANSI-SQL标准-1992-：基于异象"><a href="#ANSI-SQL标准-1992-：基于异象" class="headerlink" title="ANSI SQL标准(1992)：基于异象"></a>ANSI SQL标准(1992)：基于异象</h1><p>1992年<a href="http://www.adp-gmbh.ch/ora/misc/isolation_level.html">ANSI</a>首先尝试指定统一的隔离级别标准，其定义了不同级别的**异象(phenomenas)**， 并依据能避免多少异象来划分隔离标准。异象包括：</p><ul><li><strong>脏读（Dirty Read）</strong>: 读到了其他事务还未提交的数据；</li><li><strong>不可重复读（Non-Repeatable&#x2F;Fuzzy Read）</strong>：由于其他事务的修改或删除，对某数据的两次读取结果不同；</li><li><strong>幻读（Phantom Read）</strong>：由于其他事务的修改，增加或删除，导致Range的结果失效（如where 条件查询）。</li></ul><p>通过阻止不同的异象发生，得到了四种不同级别的隔离标准 (有三个异象，所以有四个隔离级别)：</p><p><img src="https://kkbabe-picgo.oss-cn-hangzhou.aliyuncs.com/img/ansi_def.png" alt="ANSI Define"></p><p>ANSI SQL标准看起来是非常直观的划分方式，不想要什么就排除什么，并且做到了实现无关。然而，现实并不像想象美好。因为它并<strong>不正确</strong>。</p><h1 id="A-Critique-of-ANSI-1995-：基于锁"><a href="#A-Critique-of-ANSI-1995-：基于锁" class="headerlink" title="A Critique of ANSI(1995)：基于锁"></a>A Critique of ANSI(1995)：基于锁</h1><p>几年后，微软的研究员们在<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a>一文中对ANSI的标准进行了批判，指出其存在两个致命的问题：</p><p><strong>1，不完整，缺少对Dirty Write的排除</strong></p><p>ANSI SQL标准中所有的隔离级别都没有将Dirty Write这种异象排除在外，所谓Dirty Write指的是两个未提交的事务先后对同一个对象进行了修改。而Dirty Write之所以是一种异象，主要因为他会导致下面的一致性问题：</p><blockquote><p>H0: w1[x] w2[x] w2[y] c2 w1[y] c1</p></blockquote><p>这段历史中，假设有相关性约束x&#x3D;y，T1尝试将二者都修改为1，T2尝试将二者都修改为2，顺序执行的结果应该是二者都为1或者都为2，但由于Dirty Write的发生，最终结果变为x&#x3D;2，y&#x3D;1，不一致。</p><p><strong>2，歧义</strong></p><p>ANSI SQL的英文表述有歧义。以Phantom为例，如下图历史H3：</p><blockquote><p>H3：r1[P] w2[insert y to P] r2[z] w2[z] c2 r1[z] c1</p></blockquote><p>假设T1根据条件P查询所有的雇员列表，之后T2增加了一个雇员并增加了雇员人数值z，之后T1读取雇员人数z，最终T1的列表中的人数比z少，不一致。但T1并没有在T2修改链表后再使用P中的值，是否就不属于ANSI中对Phantom的定义了呢？这也导致了对ANSI的表述可能有严格和宽松两种解读。对于Read Dirty和Non-Repeatable&#x2F;Fuzzy Read也有同样的问题。</p><p>那么，如何解决上述两个问题呢？Critique of ANSI的答案是：<strong>宁可错杀三千，不可放过一个，即给ANSI标准中的异象最严格的定义</strong>。Critique of ANSI改造了异象的定义：</p><blockquote><p>P0: w1[x]…w2[x]…(c1 or a1) (Dirty Write)</p><p>P1: w1[x]…r2[x]…(c1 or a1) (Dirty Read)</p><p>P2: r1[x]…w2[x]…(c1 or a1) (Fuzzy or Non-Repeatable Read)</p><p>P3: r1[P]…w2[y in P]…(c1 or a1) (Phantom)</p></blockquote><p>此时定义已经很严格了，直接阻止了对应的读写组合顺序。仔细可以看出，此时得到的其实就是基于锁的定义:</p><ul><li>Read Uncommitted，阻止P0：整个事务阶段对x加长写锁</li><li>Read Commited，阻止P0，P1：短读锁 + 长写锁</li><li>Repeatable Read，阻止P0，P1，P2：长读锁 + 短谓词锁 + 长写锁</li><li>Serializable，阻止P0，P1，P2，P3：长读锁 + 长谓词锁 + 长写锁</li></ul><p>#question can’t understanddd……..</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
